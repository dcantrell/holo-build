/*******************************************************************************
*
* Copyright 2017 Stefan Majewsky <majewsky@gmx.net>
*
* This file is part of Holo.
*
* Holo is free software: you can redistribute it and/or modify it under the
* terms of the GNU General Public License as published by the Free Software
* Foundation, either version 3 of the License, or (at your option) any later
* version.
*
* Holo is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
* A PARTICULAR PURPOSE. See the GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License along with
* Holo. If not, see <http://www.gnu.org/licenses/>.
*
*******************************************************************************/

package alpine

import (
	"crypto/sha256"
	"encoding/hex"
	"errors"
	"fmt"
	"regexp"
	"strings"

	"github.com/holocm/holo-build/src/holo-build/common"
)

//Generator is the common.Generator for Pacman packages (as used by Arch Linux
//and derivatives).
type Generator struct{}

var archMap = map[common.Architecture]string{
	//TODO: add ppc64le and s390x to common.Architecture enum
	common.ArchitectureAny:     "noarch",
	common.ArchitectureI386:    "x86",
	common.ArchitectureX86_64:  "x86_64",
	common.ArchitectureARMv7h:  "armhf",
	common.ArchitectureAArch64: "aarch64",
}

//RecommendedFileName implements the common.Generator interface.
func (g *Generator) RecommendedFileName(pkg *common.Package) string {
	//this is called after Build(), so we can assume that package name,
	//version, etc. were already validated
	return fmt.Sprintf("%s-%s.apk", pkg.Name, fullVersionString(pkg))
}

func fullVersionString(pkg *common.Package) string {
	str := fmt.Sprintf("%s-r%d", pkg.Version, pkg.Release)
	return str
}

//Validate implements the common.Generator interface.
func (g *Generator) Validate(pkg *common.Package) []error {
	var nameRx = `[a-z0-9-][a-z0-9-]*`
	//Alpine version numbers are of the same format as Gentoo version numbers:
	//<https://devmanual.gentoo.org/ebuild-writing/file-format/index.html>
	var versionRx = `[0-9]+(?:\.[0-9]+)*[a-z]?(?:_(?:alpha|beta|pre|rc|p)[0-9]*)*`
	errs := pkg.ValidateWith(common.RegexSet{
		PackageName:    nameRx,
		PackageVersion: versionRx,
		RelatedName:    nameRx,
		RelatedVersion: versionRx + "(?:-r[1-9][0-9]*)?", //incl. release/epoch
		FormatName:     "Alpine",
	}, archMap)

	//check for fields not supported by APK format
	unsupported := func(field string) {
		err := errors.New("The \"" + field + "\" field is not supported for Alpine packages")
		errs = append(errs, err)
	}
	if pkg.Epoch > 0 {
		unsupported("package.epoch")
	}
	if len(pkg.Conflicts) > 0 {
		unsupported("package.conflicts")
	}

	return errs
}

//Build implements the common.Generator interface.
func (g *Generator) Build(pkg *common.Package) ([]byte, error) {
	//build the data.tar.gz first
	//TODO: add "APK-TOOLS.checksum.SHA1" headers, as generated by abuild-tar(1)
	dataTarGz, err := pkg.FSRoot.ToTarGZArchive(false, true)
	if err != nil {
		return nil, err
	}

	//build control.tar.gz
	checksum := sha256.Sum256(dataTarGz)
	controlTarGz, err := buildControlTarGz(pkg, hex.EncodeToString(checksum[:]))

	//concatenate both together to form the final package
	return append(controlTarGz, dataTarGz...), nil
}

func buildControlTarGz(pkg *common.Package, datahash string) ([]byte, error) {
	var fs common.FSDirectory
	fs.Entries = make(map[string]common.FSNode)

	//render .PKGINFO
	pkginfo, err := renderPKGINFO(pkg, datahash)
	if err != nil {
		return nil, err
	}
	fs.Entries[".PKGINFO"] = &common.FSRegularFile{
		Content:  pkginfo,
		Metadata: common.FSNodeMetadata{Mode: 0644},
	}

	//add install scripts
	if script := pkg.Script(common.SetupAction); script != "" {
		file := &common.FSRegularFile{
			Content:  "#!/bin/sh\n" + script,
			Metadata: common.FSNodeMetadata{Mode: 0755},
		}
		fs.Entries[".post-install"] = file
		fs.Entries[".post-upgrade"] = file
	}
	if script := pkg.Script(common.CleanupAction); script != "" {
		fs.Entries[".post-deinstall"] = &common.FSRegularFile{
			Content:  "#!/bin/sh\n" + script,
			Metadata: common.FSNodeMetadata{Mode: 0755},
		}
	}

	//compile into control.tar
	controlTar, err := fs.ToTarArchive(false, true)
	if err != nil {
		return nil, err
	}

	//remove trailer (the 2 empty blocks = 1024 bytes) at the end, so that we can
	//concatenate data.tar.gz later to create a single gzipped tar archive
	controlTar = controlTar[0 : len(controlTar)-1024]
	return common.CompressGZ(controlTar)
}

func renderPKGINFO(pkg *common.Package, datahash string) (string, error) {
	//normalize package description like makepkg does
	desc := regexp.MustCompile(`\s+`).ReplaceAllString(strings.TrimSpace(pkg.Description), " ")

	//generate .PKGINFO
	contents := "# Generated by holo-build\n"
	contents += fmt.Sprintf("pkgname = %s\n", pkg.Name)
	contents += fmt.Sprintf("pkgver = %s\n", fullVersionString(pkg))
	contents += fmt.Sprintf("pkgdesc = %s\n", desc)
	contents += "url = \n"
	if pkg.Author == "" {
		contents += "maintainer = Unknown Packager\n"
	} else {
		contents += fmt.Sprintf("maintainer = %s\n", pkg.Author)
	}
	contents += fmt.Sprintf("size = %d\n", pkg.FSRoot.InstalledSizeInBytes())
	contents += fmt.Sprintf("arch = %s\n", archMap[pkg.Architecture])
	//TODO: right license string?
	contents += "license = custom:none\n"
	contents += compilePackageRelations("replaces", pkg.Replaces)
	contents += compilePackageRelations("provides", pkg.Provides)
	contents += compilePackageRelations("depend", pkg.Requires)
	contents += "datahash = " + datahash + "\n"

	return contents, nil
}

//TODO: verify syntax for package relations
func compilePackageRelations(relType string, rels []common.PackageRelation) string {
	if len(rels) == 0 {
		return ""
	}

	lines := make([]string, 0, len(rels)) //only a lower boundary on the final size, but usually a good guess
	for _, rel := range rels {
		if len(rel.Constraints) == 0 {
			//simple relation without constraint, e.g. "depend = linux"
			lines = append(lines, fmt.Sprintf("%s = %s", relType, rel.RelatedPackage))
		} else {
			for _, c := range rel.Constraints {
				//relation with constraint, e.g. "conflict = holo<0.5"
				lines = append(lines, fmt.Sprintf("%s = %s%s%s", relType, rel.RelatedPackage, c.Relation, c.Version))
			}
		}
	}
	return strings.Join(lines, "\n") + "\n"
}
